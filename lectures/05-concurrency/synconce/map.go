// Package synconce демонстрирует использование sync.Map + sync.Once
// для реализации потокобезопасного кеша БЕЗ дублирования вычислений.
//
// Это альтернатива memo4, использующая sync.Once вместо канала.
//
// sync.Map - специальная map, оптимизированная для случаев:
//   - Когда ключи записываются один раз и потом только читаются
//   - Когда разные горутины работают с разными ключами
//   - Когда нужна высокая производительность чтения
//
// Методы sync.Map:
//   - Load(key) - безопасное чтение (без лока на чтение!)
//   - Store(key, value) - безопасная запись
//   - LoadOrStore(key, value) - атомарная операция: если ключа нет - записать,
//     иначе вернуть существующее значение
//   - Delete(key) - удалить ключ
//
// sync.Once - примитив, гарантирующий выполнение функции ровно один раз.
//   - Первый вызов Do(f) выполнит f()
//   - Последующие вызовы Do() будут ждать завершения первого
//   - После завершения первого все последующие вызовы вернутся сразу
//
// Пример использования sync.Once:
//
//	var once sync.Once
//	var config Config
//
//	func GetConfig() Config {
//	    once.Do(func() {
//	        config = loadExpensiveConfig() // вызовется только один раз
//	    })
//	    return config
//	}
package synconce

import "sync"

// cache - глобальный потокобезопасный кеш на основе sync.Map
var cache sync.Map

// result - результат вычисления
type result struct{}

// do имитирует дорогую операцию вычисления
func do(key string) *result { return new(result) }

// entry хранит результат и sync.Once для обеспечения однократного вычисления.
// Важно: каждый entry содержит свой собственный sync.Once!
type entry struct {
	res *result  // результат вычисления
	sync.Once    // гарантирует однократное вычисление
}

// get получает значение из кеша или вычисляет его.
//
// Алгоритм работы:
//
//  1. Создаем новый entry (на случай если это первый запрос)
//  2. Пытаемся атомарно вставить entry в cache через LoadOrStore:
//     - Если ключа не было: наш entry сохранен, loaded = false
//     - Если ключ уже есть: получаем существующий entry, loaded = true
//  3. Вызываем myEntry.Do() - это гарантирует что вычисление произойдет
//     ровно один раз, даже если несколько горутин одновременно вызвали get()
//
// Пример с несколькими горутинами:
//
//	// Горутина 1:
//	get("x")
//	myEntry1 := &entry{}
//	old, loaded := cache.LoadOrStore("x", myEntry1)
//	// loaded = false, в cache теперь myEntry1
//	myEntry1.Do(func() {
//	    myEntry1.res = do("x")  // ВЫЧИСЛЯЕМ
//	})
//
//	// Горутина 2 (одновременно с горутиной 1):
//	get("x")
//	myEntry2 := &entry{}
//	old, loaded := cache.LoadOrStore("x", myEntry2)
//	// loaded = true, получили myEntry1 из кеша!
//	myEntry1.Do(func() {        // вызываем Do на entry из горутины 1
//	    ...                     // ЖДЕМ завершения вычисления в горутине 1
//	})
//
// Результат:
//   - do("x") вызвана только ОДИН раз (в горутине 1)
//   - Горутина 2 дождется результата благодаря sync.Once
//   - Нет дублирования вычислений!
//
// Сравнение с memo4:
//   - memo4 использует канал для ожидания
//   - synconce использует sync.Once для ожидания
//   - Оба подхода работают, sync.Once проще но менее гибкий
//   - sync.Map оптимизирован для частых чтений после записи
func get(key string) *result {
	// Создаем новый entry на случай если это первый запрос для этого ключа
	myEntry := &entry{}

	// LoadOrStore атомарно:
	// - Если ключа нет: сохраняет myEntry, возвращает (myEntry, false)
	// - Если ключ есть: возвращает (существующий entry, true)
	old, loaded := cache.LoadOrStore(key, myEntry)
	if loaded {
		// Ключ уже был в кеше - используем существующий entry
		// Этот entry мог быть создан другой горутиной
		myEntry = old.(*entry)
	}
	// Иначе: наш новый myEntry теперь в кеше

	// sync.Once гарантирует что этот код выполнится ровно один раз
	// для данного entry, даже если несколько горутин одновременно
	// вызовут Do() на одном и том же entry.
	//
	// Первый вызов Do() выполнит функцию, остальные дождутся завершения.
	myEntry.Do(func() {
		myEntry.res = do(key)
	})

	// К этому моменту res гарантированно вычислен
	return myEntry.res
}

// OMIT
